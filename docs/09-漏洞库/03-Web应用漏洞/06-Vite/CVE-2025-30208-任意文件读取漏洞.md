# 1、漏洞信息

Vite是一个现代化的前端构建工具，旨在提供更快的开发体验。它通过基于原生ES模块的开发服务器，在开发过程中实现极速热更新（HMR）。Vite在构建时使用了高度优化的打包工具，如esbuild，极大提高了构建速度。它支持多种前端框架（如React、Vue）并可以通过插件扩展功能。Vite的目标是简化前端开发工作流，并提升开发效率。



攻击者可以绕过 `server.fs.deny` 功能，该功能旨在限制对 Vite 服务允许列表之外的文件的访问。可通过构造包含`?raw??`或`?import&raw??`附加到使用 `@fs` 前缀的 URL，攻击者可以读取文件系统上的任意文件，只要 Node.js 进程具有读取文件的权限即可。该问题源于系统在处理URL查询参数时未正确识别尾部分隔符，导致绕过控制逻辑。仅当开发服务器通过`--host`或`server.host`暴露至网络时，漏洞才可被利用。



# 2、漏洞概述

| 漏洞名称  | 任意文件读取漏洞                                |
| --------- | ----------------------------------------------- |
| 漏洞等级  | 中危                                            |
| CVE编号   | CVE-2025-30208                                  |
| CNVD编号  | 暂无                                            |
| CNNVD编号 | 暂无                                            |
| 其他编号  | 暂无                                            |
| 披露时间  | 2025-03-24                                      |
| 分数      | 5.3                                             |
| CVSS      | CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:N/A:N    |
| 披露链接  | https://www.cve.org/CVERecord?id=CVE-2025-30208 |



# 3、影响范围

```
6.2.0 <= vite < 6.2.3
6.1.0 <= vite < 6.1.2
6.0.0 <= vite < 6.0.12
5.0.0 <= vite < 5.4.15
vite < 4.5.10
```



# 4、环境搭建

```
git clone --depth 1 https://github.com/vulhub/vulhub.git
cd /opt/vulhub/vite/CVE-2025-30208/
docker compose up -d
```

浏览器访问`http://YOUIP:5173`



# 5、代码审计

以`v6.2.2`进行分析

```
http://localhost:5173/@fs/C://windows/win.ini
```

根据修复代码定位到`packages\vite\src\node\server\middlewares\transform.ts`，在URL出打下断点，跳入到`removeTimestampQuery`方法中

![image-20250427133637366](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271336659.png)



这里出现两个正则

```
#用于匹配特定格式的时间戳字符串t=1234567890123
const timestampRE = /\bt=\d{13}&?\b/

#检查url是否以?或&结尾
const trailingSeparatorRE = /[?&]$/
```

![image-20250427133714541](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271337593.png)

![image-20250427133728156](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271337251.png)



在过滤处理后当前的URL

![image-20250427133804594](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271338671.png)



跳回原来的方法继续执行，以下是一些if判断均不满足条件直接跳过

![image-20250427133821255](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271338349.png)

![image-20250427133842511](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271338602.png)

![image-20250427133856575](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271338692.png)



到了关键处，观察if表达式存在逻辑表达式和短路求值的内容：

![image-20250427133916009](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271339073.png)



```
A || B：如果 A 为 true，则不会执行 B
A && B：如果 A 为 false，则不会执行 B
```

会先判断`(rawRE.test(url) || urlRE.test(url))`当满足`rawRE.test(url)=false`并且`urlRE.test(url)=false`时则跳过`ensureServingAccess`函数，该函数则为vite服务器的一个安全函数用于检查请求的 URL 是否允许被 Vite 服务访问

https://vite.dev/config/server-options.html#server-fs-allow

![image-20250427134005481](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271340578.png)



ensureServingAccess代码

![image-20250427134040806](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271340905.png)



接下来看两个正则

```
#匹配url是否有url参数
export const urlRE = /(\?|&)url(?:&|$)/
#匹配url是否有raw参数
export const rawRE = /(\?|&)raw(?:&|$)/
```

![image-20250427134109094](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271341190.png)



此时我们的url为

```
/@fs/C://windows/win.ini?import&raw?
```

首先我们的url内容没有url参数，满足`rawRE.test(url)=false`即可

```
rawRE.test("/@fs/C://windows/win.ini?import&raw?")
```

![image-20250427134154708](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271341808.png)



为什么POC没有被正则匹配到，是因为这段正则出现了问题，`/(\?|&)raw(?:&|$)/`只匹配`raw` 后的&或字符串结尾，`raw?`正好绕过

![image-20250427134315925](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271343983.png)

![image-20250427134325144](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271343202.png)



再看官方的修复对比v6.2.2和v6.2.3增加了一条正则进行匹配，这段正则专门匹配URL 末尾是否有多余的查询参数分隔符（`?` 或 `&`）从而修复了该问题

```
const trailingQuerySeparatorsRE = /[?&]+$/
```

![image-20250427134545073](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271345174.png)



# 6、漏洞复现

首先，尝试使用标准 `@fs` 前缀访问 `/etc/passwd`，以验证是否正确阻止了对允许目录之外的文件的正常访问

```
/@fs/etc/passwd
```

![image-20250427135140098](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271351222.png)



将 `?raw??` 附加到 URL，可以绕过此限制并检索文件的内容

```
/@fs/etc/passwd?raw??
```

![image-20250427135254841](https://cdn.jsdelivr.net/gh/xmtxsec/picture/imgl/202504271352967.png)



# 7、解决方案

## 7.1、临时缓解方案

如果暂时无法升级，可以采取以下措施降低风险：

限制网络访问：避免使用 `--host` 或设置 `server.host` 为 `localhost`，确保开发服务器仅限本地访问。

严格文件权限：确保敏感文件不可被 Vite 进程读取（例如通过操作系统权限控制）。



## 7.2、升级修复方案

Vite 官方已发布安全补丁，修复版本包括：

```
6.2.6、6.1.5、6.0.15、5.4.18、4.5.13
```

请尽快通过 `npm update vite` 或手动升级到以上版本以修复漏洞。



# 8、POC

https://github.com/kk12-30/CVE-2025-30208

 

```
/@fs/etc/passwd?raw??
```



# 9、参考链接

https://cloud.tencent.com/developer/article/2513407

https://zhuanlan.zhihu.com/p/1888287048588301186







